# 객체지향 프로그래밍
#### [객체지향 프로그래밍(OOP, Object Oriented Programming)]
- 객체: 데이터와 관련된 메서드를 하나의 단위로 묶어놓은 것
- 객체지향 프로그래밍: 객체 단위로 코드를 작성하며, 객체 간의 상호작용으로 프로그램을 설계
- 객체 모델링: 현실세계의 객체를 SW 객체로 설계하는 것
#### [클래스]
- 객체를 만들기 위한 설계도
#### [인스턴스]
- 클래스를 통해 생성된 객체
- 객체는 일반적 용어이며, 인스턴스는 특정 클래스를 이용해 생성된 하나의 객체를 지칭
- 인스턴스는 클래스의 한 사례(특정 클래스를 사용해서 객체를 생성하는 맥락)

### 객체지향 프로그래밍의 특징
- 추상화: 객체의 불필요한 세부사항을 숨기고 필요한 인터페이스만을 제공함. 구현에 의존하지 않는 설계
- 다형성: 상속 또는 구현 관계에 있을 때 객체들이 서로 다른 방식으로 동작
- 상속: 기존의 설계도를 재사용(확장), 하나의 클래스가 다른 클래스의 속성과 메서드를 물려받음
- 캡슐화: 객체의 데이터와 메서드를 하나로 묶고, 외부로부터 객체의 세부 사항을 숨기는 것
### 객체지향 프로그래밍의 장점
- 재사용성
- 유지보수성
- 유연성과 확장성

# 클래스
### 함수
- 특정 작업수행과 관련된 문장들을 하나로 묶어서 이름을 붙인 것
- 실행 가능한 단위
- 다른 곳에서 호출할 때는 `함수이름();`
- 자바에서는 함수가 클래스의 일부분으로서 존재(메서드: 객체의 멤버 함수)
```java
public class {
    public static 반환형 함수이름(타입 매개변수1, 타입 매개변수2, ...) {
        // void는 반환값이 없음!!

        // 코드 실행 내용

        return 반환값;
    }
}
```

## 클래스
- 관련있는 변수와 함수를 묶어서 만든 사용자정의 데이터타입
    - member field: 멤버 변수(객체의 속성(상태))
    - member method: 멤버 베서드(객체의 동작(로직))
- 프로그래밍의 목적을 고려하여 클래스를 설계하고 객체를 생성
- 각 객체들이 어떤 특징(속성과 동작)을 가지고 있을지 결정한다.
- 클래스를 통해 생성된 객체를 '인스턴스'라고 한다.
- 객체들은 메서드를 통해 상호작용한다(서로 메시지를 주고 받는다).
- 데이터와 메서드를 하나로 묶어 캡슐화한다.
- 멤버 메서드에서는 멤버 변수에 대한 접근이 자유롭다(매개변수로 넘길 필요 없음!!)

### 클래스의 구성 요소
- 멤버 변수(Member Field)- 속성(Attribute)
- 멤버 메서드(Member Method)- 동작(Behavior)
- 생성자(Constructor)
- 중첩 클래스(Nested Class)

### 클래스 선언 문법
```java
[접근제어자] [final|abstract] class 클래스이름{
    // 멤버 변수, 필드 (속성 정의)
    [접근제어자] [static] [final] 데이터타입 변수이름 [=초기값];

    // 생성자
    [접근제어자] 클래스이름([매개변수들]) {
        생성자 본문
    }

    // 메서드 (기능 정의)
    [접근제어자] [static] [final] 반환타입|void 메서드이름([매개변수들]) {
        메서드 본문
    }
}
```

### 객체 생성 문법
`클래스이름 객체이름 new 클래스이름([생성자매개변수들])`

### 객체 멤버 접근
- 멤버 변수의 값 접근
    - `객체이름.멤버변수이름`
- 멤버 메서드 호출
    - `객체이름.멤버메서드이름([매개변수들]);
`
### 변수의 종류
| 변수 종류 | 선언 | 생성 시기 | 특징 | 메모리 영역 |
|:--------:|:----:|:--------:|:----:|:----------:|
| 클래스 변수| 클래스에서 멤버 필드 선언 시 static 키워드를 사용 | 클래스가 메모리에 로드될 때 생성| 모든 인스턴스가 공유하는 변수 | 메서드 영역(Method Area) |
| 인스턴스 변수 | 클래스에서 멤버 필드 선언 시 static 키워드 없이 선언 | 인스턴스가 생성될 때 생성 | 각 인스턴스마다 별도로 생성 | 힙 영역(Heap) |
| 지역 변수 | 메서드, 생성자 또는 초기화 블록 내에서 선언 | 선언된 블록이 실행될 때 생성 | 블록이 끝나면 소멸 | 스택 영역(Stack) |

## 메서드
- 객체가 할 수 있는 행동을 정의
- 어떤 작업을 수행하는 명령문의 집합에 이름을 붙여놓은 것
- 메서드의 이름은 소문자로 시작하는 것이 관례

### 메서드 선언
```java
[접근제어자] [static] [final] 반환타입|void 메서드이름([매개변수들]) {
    메서드 본문
}

// 메인 메서드:
public static void main(String[] args) {}
```
- 선언 시 {} 안에 메서드가 해야 할 일을 정의

### 메서드 호출
- 객체를 생성한 후 객체의 멤버 메서드를 호출한다.
- `클래스객체.메서드이름`으로 호출
    ```
    Person p = new Person();
    p.info();
    ```
- static이 메서드에 선언되어 있을 때는 `클래스이름.메서드이름`으로 호출
    ```java
    Person.hello();
    ```

#### 매개변수(Parameter)
- 메서드에서 사용하는 것
#### 인자(Argument)
- 호출하는 쪽에서 전달하는 것
- 매개변수 생략 가능
- 파라미터 전달 시 묵시적 형변환 이루어짐
    - 묵시적 형변환이 안되는 방향이라면? → 메서드 오버로딩 통해 해결 가능

### 메서드 오버로딩
- 이름이 같고 매개변수가 다른 메서드를 여러 개 정의하는 것
- 중복 코드에 대한 효율적 관리 가능
- `파라미터의 개수 또는 순서, 타입이 달라야 할 것`
    - 파라미터 이름만 다른 것은 의미가 없다.
    - 리턴 타입이 다른 것은 의미가 없다.
```java
// 변수 타입이 다르다 → 오버로딩 가능
void study(long time) {
    System.out.println(time +"시간 동안 공부합니다.");
}
void study(double time) {
    System.out.println(time +"시간 동안 공부합니다.");
}

// 변수 이름만 다르다 → 오버로딩 불가능
void study(long time) {
    System.out.println(time +"시간 동안 공부합니다.");
}
void study(String minute) {
    System.out.println(minute +"시간 동안 공부합니다.");
}

// 변수 순서가 다르다 → 오버로딩 가능
void study(String subject, int time) {
    System.out.println(subject+"를 "+time +"시간 동안 공부합니다.");
}
void study(int time, String subject) {
    System.out.println(subject+"를 "+time +"시간 동안 공부합니다.");
}
```

> 클래스 예시 코드
```java
// Person 클래스 생성
// class 클래스이름 {}
class Person {
    // 멤버 변수(데이터)
    // 데이터타입 변수이름 [=초기값];
    String name;
    int age;
    String hobby;

    // 관련된 데이터와 로직을 하나로 묶어준다.
    // 멤버 메서드
    // 멤버 변수는 객체(인스턴스) 자기 자신이 가지고 있는 것이므로 매개변수로 넘기지 않아도 접근 가능
    void info() {
        System.out.println("이름은 "+name+"이고, 나이는 "+age+"세입니다.");
        System.out.println("취미는 "+hobby+"입니다. ");
    }
}

public class PersonTest {
    public static void main(String[] args) {
        // 클래스를 이용해 객체를 생성(인스턴스)
        // 클래스이름 객체이름 = new 클래스이름

        // yang은 Person의 인스턴스
        Person yang = new Person();

        // yang의 멤버 변수
        yang.name = "Yang";
        yang.age = 45;
        yang.hobby = "YouTube";

        // yang의 멤버 변수를 이용한 info() 메서드(함수) 실행 결과
        yang.info();
        


        // hong은 Person의 인스턴스
        Person hong = new Person();
        
        // hong의 멤버 변수
        hong.name = "Hong";
        hong.age = 25;
        hong.hobby = "Golf";

        // hong의 멤버 변수를 이용한 info() 메서드(함수) 실행 결과
        hong.info();
    }
}
```

# 생성자
- 객체를 생성할 때 사용됨
    - new 키워드와 함께 호출하여 객체 생성
- 생성자는 클래스와 동일한 이름을 가짐
- 반환 타입이 없음(void도 X)
- 객체가 생성될 때 반드시 하나의 생성자 호출
- 멤버 필드를 초기화 하는 데 주로 사용됨
- 기본 생성자의 자동 제공
    - 기본 생성자: 매개변수가 없고 내용이 없는 생성자
    - 클래스에 생성자가 하나도 정의되지 않으면, 컴파일러가 자동으로 매개변수가 없는 기본 생성자를 추가함
- 생성자 오버로딩(매개변수의 개수나 타입이 다른 여러개의 생성자 정의) 가능
- this()를 사용한 생성자 호출
    - 생성자의 첫번째 라인에서 this()를 사용하여 같은 클래스의 다른 생성자를 호출할 수 있음

## 기본 생성자
- `[접근제어자] 클래스명() {}`
- 매개변수와 내용이 없는 생성자
```java
public class Dog {
    // 기본 생성자 : 클래스 이름과 동일한 이름
    public Dog() { }
}

public class Main{
    public static void main(String[] a) {
        // `new 생성자()` 를 통해 객체 생성
        Dog d = new Dog();
    }
}
```

## 파라미터가 있는 생성자
- 생성자의 목적이 필드 초기화
- 프로그래머가 생성자를 하나라도 만든다면 컴파일러는 기본 생성자를 생성할 수 없음
    - 기본 생성자는 웬만하면 만드는 게 좋다.

### 생성자 오버로딩
```java
class Dog {
    String name;
    int age;
    
    Dog() {

    }

    Dog(String name, int age) {
        // this. 통해 구별
        // this. : 내(생성된 인스턴스)가 가지고 있는
        // 즉, 객체(인서튼스) 나 자신을 가리키는 참조값
        this.name = name;
        this.age = age;
    }

    Dog(String name) {
        this(name, 5);  // 내가 이미 가지고 있는 생성자를 호출
        // 제약사항: 반드시 생성자 본문에서 첫줄에 위치해야 함 !
    }

    Dog(int age) {
        this("무명", age);
    }
}

public class Main{
    public static void main(String[] a) {
        // `new 생성자()` 를 통해 객체 생성
        Dog d = new Dog();
        Dog d2 = new Dog("뭉치");
        Dog d3 = new Dog(3);
        Dog d4 = new Dog("돌돌이", 3);
    }
}
```

### this.
- 참조 변수로써 현재 인스턴스 자신을 가리킴
- `this.` 이용하여 자신의 멤버에 접근 가능
- 지역변수(매개변수)와 필드의 이름이 동일할 경우 필드임을 식별할 수 있게 함(생성자에서 주로 활용)
- 인스턴스에 대한 참조이므로 static 메서드 또는 static 블록에서 사용 불가
- 메서드 체이닝 : 메서드에서 this를 반환하여 메서드 호출을 연쇄적으로 이어갈 수 있음
- this([생성자 매개변수들])를 호출하여 생성자 안에서 같은 클래스 내의 다른 생성자를 호출
    - this()를 이용한 생성자 호출은 반드시 생성자 내에서만 가능
    - this() 구문을 생성자 안에서 사용할 때에는 반드시 첫번째 줄에 위치

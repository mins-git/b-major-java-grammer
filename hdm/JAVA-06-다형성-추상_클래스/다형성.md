# 다형성

- 실제 하나의 객체를 다양한 타입의 참조로 사용하는 것
- 다양한 유형의 객체를 하나의 공통된 타입으로 참조할 수 있는 것
- 상속 관계에 있을 때 `조상클래스 타입으로 자손 클래스의 객체를 참조 할 수 있음`
- `다양한 타입으로 참조하더라도 참조만 바뀔 뿐 실제 객체 자체(행위)는 변함 없다.`
- 하나의 이름으로 다양한 기능을 구현할 수 있다.

## 다형성의 종류
- 임시 다형성 : `메서드 오버로딩`, `연산자 오버로딩`
- 매개변수 다형성: 제네릭
- 서브타입 다형성: 상속 관계에 있을 때 조상 클래스의 타 입으로 자손 객체 참조 가능함.


## 다형성의 장점?
- 코드의 재사용성 증가, 유연성과 확장성 증가, 가독성 개선됨.

- 다형성 코드  예시
- `Person p = new Student(); // 다형성`
```java
public class Test {
    public static void main(String[] args) {
        // 다형성
        // 상속 관계에 있을때, 조상 클래스의 타입으로 자손 클래스 객체 참조 가능
        Student st = new Student();
        Person p = new Student(); // 다형성
        Object obj = new Student();
        
        // 관점을 바꾼다고해도 실제 메모리에 생성된 인스턴스는 변함이 없다.
        // 관점만 바뀐것임.
        // 부모 클래스의 타입으로 참조를 바꾸면
        // 부모 클래스에 정의된 메서드, 변수만 접근 가능하다.
        // 실제 메모리에 올라와있는 객체는 더 많은 메서드와 멤버 변수가 있더라도 접근 불가

        // 동적 바인딩
        // - 상속을 하면서, 자손 클래스에서 오버라이드 한 상황
        // - 타입과 상관없이 실제 객체가 가진 메섣 ㅡ호출됨
        // - 타입과 관계없이 실제 객체의 행위를 함.
        // - 타입만 가지고는 판단x
    }
}
```
### 참조변수의 형 변환
- 조상타입 -> 자손타입(명시적 형 변환) : 생략 불가
- 자손타입 -> 조상타입(묵시적 형 변환) : 생략 가능

- 명시적 형 변환은 생략이 불가능하다.


```java
        Person p = new Student(); // 다형성
        // 묵시적 형변환: 자손 타입=> 조상 타입

//        `Student st = (Student) new Person();` // 되는것 처럼 보이나 안됨.
        // 컴파일은 되지만 실행중에 에러가 발생함
        // 컴파일: 문법적 오류만 검사함.
        // 명시적 형변환인데 에러가 나는 경우?
        // 자손 객체를 만든다음 부모 클래스로 형 변환 했다가, 다시 돌아오는 경우
        // ex)
        Student st = (Student) p; // 이경우는 됨.

```

### 참조 변수와 인스턴스 멤버의 관계
- 상속관계에서 멤버변수가 중복이 되면 변수 타입에 따라 연결이 달라진다.(다형성x)
- 동적 바인딩: 메서드가 중복될 때(오버라이딩), 참조 변수의 타입에 상관없이 항상 실제 인스턴스의 자식 클래스 메서드가 호출됨
- static 메서드는 참조변수 타입의 영향을 받기 때문에 이를 방지하고자 클래스 이름으로 메서드 호출을 권장함.


# Queue
- queue는 인터페이스 구현체는 linkedlist를 사용함.
- 큐 자료구조 : FIFO 가장 먼저 들어온값 가장먼저 빠지도록
- bollean offer: 데이터를 추가
- E peek(): 가장 앞에있는 데이터 조회
- E pool(): 가장 뒤에 있는 데이터 빼기
- boolean isEmpty(): 큐 빈여부 체크

## Queue 주요 메서드

| 메서드                              | 설명                                                                 |
|----------------------------------|--------------------------------------------------------------------|
| `add(E e)`                       | 큐에 데이터를 추가                                                   |
| `offer(E e)`                     | 큐에 데이터를 추가하며 성공 여부 반환                                  |
| `remove()`                       | 큐의 첫 번째 요소를 제거                                              |
| `poll()`                         | 큐의 첫 번째 요소를 반환하고 제거 (비어있으면 `null` 반환)              |
| `element()`                      | 큐의 첫 번째 요소를 반환 (비어있으면 예외 발생)                         |
| `peek()`                         | 큐의 첫 번째 요소를 반환 (비어있으면 `null` 반환)                      |
| `clear()`                        | 큐의 모든 요소를 제거                                                 |



# Stack
- 스택 자료구조: LIFO 가장 나중에 들어온 값이 가장 먼저 사용
- E push: 데이터추가
- E peek(): 가장 위에 있는 데이터 조 회
- E pop(): 가장 위에 있는 데이터 빼내기
- boolean isEmpty(): 스택이 비어 있는지 여부

## Stack 주요 메서드

| 메서드                              | 설명                                                                 |
|----------------------------------|--------------------------------------------------------------------|
| `push(E item)`                    | 스택에 데이터를 추가                                                 |
| `pop()`                           | 스택의 가장 위에 있는 데이터를 제거하고 반환                           |
| `peek()`                          | 스택의 가장 위에 있는 데이터를 반환 (제거하지 않음)                     |
| `empty()`                         | 스택이 비어있는지 체크 (true/false 반환)                               |
| `search(Object o)`                | 스택에서 지정된 객체의 위치를 반환, 없으면 -1 반환                      |



# Deque
- 덱은 인터페이스, 구현체는 ArrayDequqe, LinkedList 사용함.

## Deque 주요 메서드

| 메서드                              | 설명                                                                 |
|----------------------------------|--------------------------------------------------------------------|
| `addFirst(E e)`                   | 덱의 첫 번째 위치에 데이터를 추가                                      |
| `addLast(E e)`                    | 덱의 마지막 위치에 데이터를 추가                                       |
| `removeFirst()`                   | 덱의 첫 번째 요소를 제거                                              |
| `removeLast()`                    | 덱의 마지막 요소를 제거                                               |
| `getFirst()`                      | 덱의 첫 번째 요소를 반환 (제거하지 않음)                               |
| `getLast()`                       | 덱의 마지막 요소를 반환 (제거하지 않음)                                |
| `offerFirst(E e)`                 | 덱의 첫 번째 위치에 데이터를 추가하며 성공 여부 반환                     |
| `offerLast(E e)`                  | 덱의 마지막 위치에 데이터를 추가하며 성공 여부 반환                      |
| `pollFirst()`                     | 덱의 첫 번째 요소를 제거하고 반환 (비어있으면 `null` 반환)               |
| `pollLast()`                      | 덱의 마지막 요소를 제거하고 반환 (비어있으면 `null` 반환)                |
| `clear()`                         | 덱의 모든 요소를 제거                                                 |






## Java의 ArrayList vs LinkedList

### ArrayList
- **조회**: 빠름 (O(1))
  - 인덱스를 통해 직접 접근 가능.
  
- **추가**: 느림 (O(n) 최악의 경우)
  - 배열 크기를 초과할 경우 새로운 배열을 생성하고 기존 요소를 복사해야 함. 중간에 추가할 경우에도 요소를 이동해야 함.

- **삭제**: 느림 (O(n))
  - 중간에 요소를 삭제하면 삭제된 위치 이후의 모든 요소를 이동해야 하므로 시간이 소요됨.

### LinkedList
- **조회**: 느림 (O(n))
  - 요소에 접근하려면 처음부터 순차적으로 찾아야 하므로 상대적으로 느림.

- **추가**: 빠름 (O(1))
  - 노드를 추가할 위치만 알고 있다면, 그 위치에 노드를 연결하는 방식으로 추가하므로 빠름.

- **삭제**: 빠름 (O(1))
  - 삭제할 노드를 알고 있다면, 해당 노드를 간단히 연결을 변경하여 삭제할 수 있으므로 빠름.

### 요약
- **ArrayList**: 빠른 조회, 느린 추가 및 삭제
- **LinkedList**: 느린 조회, 빠른 추가 및 삭제

- 데이터의 사용 패턴에 따라 적절한 자료구조를 선택하는 것이 중요하다!
